using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DV.Logic.Job;
using DV.Printers;
using DV.ThingTypes;
using HarmonyLib;
using MessageBox;
using PersistentJobsMod.Extensions;
using PersistentJobsMod.ModInteraction;
using PersistentJobsMod.Utilities;
using UnityEngine;
using Random = System.Random;

namespace PersistentJobsMod.HarmonyPatches.JobValidators {
    /// <summary>expires a job if none of its cars are in range of the starting station on job start attempt</summary>
    [HarmonyPatch(typeof(JobValidator), "ProcessJobOverview")]
    public static class JobValidator_ProcessJobOverview_Patch {
        public static bool Prefix(JobValidator __instance, PrinterController ___bookletPrinter,
            JobOverview jobOverview) {
            try {
                if (!Main._modEntry.Active) {
                    return true;
                }

                var job = jobOverview.job;
                var allStations = UnityEngine.Object.FindObjectsOfType<StationController>();
                var stationController = allStations.FirstOrDefault(
                    st => st.logicStation.availableJobs.Contains(job)
                );

                if (___bookletPrinter.IsOnCooldown || job.State != JobState.Available || stationController == null) {
                    return true;
                }

                // for shunting (un)load jobs, require cars to not already be on the warehouse track
                if (Main.Settings.PreventStartingShuntingJobForCarsOnWarehouseTrack) {
                    if (job.jobType == JobType.ShuntingLoad || job.jobType == JobType.ShuntingUnload) {
                        var wt = job.tasks.Aggregate(
                            null as Task,
                            (found, outerTask) => found == null
                                ? TaskUtilities.TaskFindDfs(outerTask, innerTask => innerTask is WarehouseTask)
                                : found) as WarehouseTask;
                        var wm = wt != null ? wt.warehouseMachine : null;
                        if (wm != null && job.tasks.Any(
                                outerTask => TaskUtilities.TaskAnyDfs(
                                    outerTask,
                                    innerTask => IsAnyTaskCarOnTrack(innerTask, wm.WarehouseTrack)))) {
                            __instance.StartCoroutine(HandleCarsAlreadyOnWarehouseTrackCoroutine(___bookletPrinter));
                            return false;
                        }
                    }
                }

                // expire the job if all associated cars are outside the job destruction range
                // the base method's logic will handle generating the expired report
                var stationRange = stationController.stationRange;
                if (!job.tasks.Any(
                        outerTask => TaskUtilities.TaskAnyDfs(
                            outerTask,
                            innerTask => AreTaskCarsInRange(innerTask, stationRange)))) {
                    job.ExpireJob();
                    return true;
                }

                // reserve space for this job
                var stationJobControllers = UnityEngine.Object.FindObjectsOfType<StationProceduralJobsController>();

                var jobChainController = stationJobControllers.SelectMany(sjc => sjc.GetCurrentJobChains()).FirstOrDefault(jcc => jcc.currentJobInChain == job);

                if (jobChainController == null) {
                    Debug.LogWarning($"[PersistentJobs] could not find JobChainController for Job[{job.ID}]");
                } else if (job.jobType == JobType.ShuntingLoad) {
                    // shunting load jobs don't need to reserve space
                    // their destination track task will be changed to the warehouse track
                    Main._modEntry.Logger.Log($"skipping track reservation for Job[{job.ID}] because it's a shunting load job");
                } else {
                    var didAnyTrackChange = ReserveOrReplaceRequiredTracks(jobChainController);
                    if (didAnyTrackChange) {
                        PersistentJobsModInteractionFeatures.InvokeJobTrackChanged(job);
                    }
                }

                // for shunting load jobs, don't require player to spot the train on a track after loading
                if (job.jobType == JobType.ShuntingLoad) {
                    // TODO SL jobs generated by PJ should already have the warehouse track set as destination. decide if this additional handling here can be omitted.
                    ReplaceShuntingLoadDestination(job);
                    PersistentJobsModInteractionFeatures.InvokeJobTrackChanged(job);
                }
            } catch (Exception e) {
                Main.HandleUnhandledException(e, nameof(JobValidator_ProcessJobOverview_Patch) + "." + nameof(Prefix));
            }
            return true;
        }

        private static void ReplaceShuntingLoadDestination(Job job) {
            Main._modEntry.Logger.Log("attempting to replace destination track with warehouse track...");
            var sequence = job.tasks[0] as SequentialTasks;
            if (sequence == null) {
                Debug.LogError("    couldn't find sequential task!");
                return;
            }

            // TODO rewrite this using sequence.GetTaskData().nestedTasks
            var tasks = sequence.tasks;

            if (tasks == null) {
                Debug.LogError("    couldn't find child tasks!");
                return;
            }

            var cursor = tasks.First;

            if (cursor == null) {
                Debug.LogError("    first task in sequence was null!");
                return;
            }

            while (cursor != null && TaskUtilities.TaskAnyDfs(
                       cursor.Value,
                       t => t.InstanceTaskType != TaskType.Warehouse)) {
                Main._modEntry.Logger.Log("    searching for warehouse task...");
                cursor = cursor.Next;
            }

            if (cursor == null) {
                Debug.LogError("    couldn't find warehouse task!");
                return;
            }

            // cursor points at the parallel task of warehouse tasks
            // replace the destination track of all following tasks with the warehouse track
            var wt = (TaskUtilities.TaskFindDfs(
                cursor.Value,
                t => t.InstanceTaskType == TaskType.Warehouse) as WarehouseTask);
            var wm = wt != null ? wt.warehouseMachine : null;

            if (wm == null) {
                Debug.LogError("    couldn't find warehouse machine!");
                return;
            }

            while ((cursor = cursor.Next) != null) {
                Main._modEntry.Logger.Log("    replace destination tracks...");
                TaskUtilities.TaskDoDfs(
                    cursor.Value,
                    // this is rather hackish - we use a traverse to access the Task.destinationTrack field, but actually that field is only defined on TransportTask
                    t => Traverse.Create(t).Field("destinationTrack").SetValue(wm.WarehouseTrack));
            }

            var jobChainController = UnityEngine.Object.FindObjectsOfType<StationProceduralJobsController>()
                .SelectMany(sjc => sjc.GetCurrentJobChains())
                .FirstOrDefault(jcc => jcc.currentJobInChain == job);

            if (jobChainController != null)
            {
                var staticJobDef = jobChainController.jobChain.FirstOrDefault(jd => jd.job == job);
                if (staticJobDef != null)
                {
                    if (staticJobDef is StaticShuntingLoadJobDefinition shuntingLoadJobDef)
                    {
                        shuntingLoadJobDef.destinationTrack = wm.WarehouseTrack;
                    }
                    else
                    {
                        Traverse.Create(staticJobDef).Field("destinationTrack").SetValue(wm.WarehouseTrack);
                    }
                }
            }

            Main._modEntry.Logger.Log("    done!");
        }

        private static bool AreTaskCarsInRange(Task task, StationJobGenerationRange stationRange) {
            // this is rather hackish - we use a traverse to access the Task.cars field, but actually that field is only defined on TransportTask and WarehouseTask
            var cars = Traverse.Create(task).Field("cars").GetValue<List<Car>>();
            var carInRangeOfStation = cars.FirstOrDefault(c => (c.TrainCar().transform.position - stationRange.stationCenterAnchor.position).sqrMagnitude <= Main._initialDistanceRegular);
            return carInRangeOfStation != null;
        }

        private static bool IsAnyTaskCarOnTrack(Task task, Track track) {
            // this is rather hackish - we use a traverse to access the Task.cars field, but actually that field is only defined on TransportTask and WarehouseTask
            var cars = Traverse.Create(task).Field("cars").GetValue<List<Car>>();
            return cars.Any(car => car.FrontBogieTrack == track);
        }

        private static bool ReserveOrReplaceRequiredTracks(JobChainController jobChainController) {
            var jobChain = jobChainController.jobChain;

            bool didAnyTrackChange = false;

            var random = new Random();

            for (var i = 0; i < jobChain.Count; i++) {
                var staticJobDefinition = jobChain[i];
                if (staticJobDefinition == null) {
                    var message = $"[PersistentJobs] The jobChain of a JobChainController contains a null value at index {i}. List of jobs in the jobChain: {string.Join(", ", jobChain.Select(sjd => sjd?.job?.ID ?? "null"))}";
                    Debug.LogError(message);
                    throw new InvalidOperationException(message);
                }

                var job = staticJobDefinition.job;

                if (job == null) {
                    var message = $"[PersistentJobs] The job of a StaticJobDefinition ({staticJobDefinition.GetType()}) at index {i} in the jobChain of a JobChainController is null. List of jobs in the jobChain: {string.Join(", ", jobChain.Select(sjd => sjd?.job?.ID ?? "null"))}";
                    Debug.LogWarning(message);
                } else {
                    if (jobChainController.jobDefToCurrentlyReservedTracks.TryGetValue(staticJobDefinition, out var trackReservations)) {
                        for (var j = 0; j < trackReservations.Count; j++) {
                            var intendedDestinationTrack = trackReservations[j].track;
                            var lengthToBeReserved = trackReservations[j].reservedLength;
                            if (YardTracksOrganizer.Instance.GetFreeSpaceOnTrack(intendedDestinationTrack) >= lengthToBeReserved) {
                                YardTracksOrganizer.Instance.ReserveSpace(intendedDestinationTrack, lengthToBeReserved, false);
                            } else {
                                // not enough space to reserve; find a different track with enough space & update job data
                                var replacementTrack = GetReplacementTrack(intendedDestinationTrack, lengthToBeReserved, random);
                                if (replacementTrack == null) {
                                    Debug.LogWarning($"[PersistentJobs] Can't find track with enough free space for Job[{job.ID}]. Skipping track reservation!");
                                } else {
                                    YardTracksOrganizer.Instance.ReserveSpace(replacementTrack, lengthToBeReserved, false);
                                    
                                    ReplaceDestinationTrackInStaticJobDefinition(staticJobDefinition, intendedDestinationTrack, replacementTrack);

                                    // update reservation data
                                    trackReservations.RemoveAt(j);
                                    trackReservations.Insert(j, new TrackReservation(replacementTrack, lengthToBeReserved));

                                    didAnyTrackChange = true;
                                }
                            }
                        }
                    } else {
                        Debug.LogError($"[PersistentJobs] No reservation data for jobChain[{i}] found!" + " Reservation data can be empty, but it needs to be in jobDefToCurrentlyReservedTracks.", staticJobDefinition);
                    }
                }
            }

            return didAnyTrackChange;
        }

        private static void ReplaceDestinationTrackInStaticJobDefinition(StaticJobDefinition staticJobDefinition, Track intendedDestinationTrack, Track replacementTrack) {
            // update static job definition data
            if (staticJobDefinition is StaticEmptyHaulJobDefinition emptyHaulJobDefinition) {
                emptyHaulJobDefinition.destinationTrack = replacementTrack;
            } else if (staticJobDefinition is StaticShuntingLoadJobDefinition shuntingLoadJobDefinition) {
                shuntingLoadJobDefinition.destinationTrack = replacementTrack;
            } else if (staticJobDefinition is StaticTransportJobDefinition transportJobDefinition) {
                transportJobDefinition.destinationTrack = replacementTrack;
            } else if (staticJobDefinition is StaticShuntingUnloadJobDefinition shuntingUnloadJobDefinition) {
                shuntingUnloadJobDefinition.carsPerDestinationTrack
                    = shuntingUnloadJobDefinition.carsPerDestinationTrack
                    .Select(cpt => cpt.track == intendedDestinationTrack ? new CarsPerTrack(replacementTrack, cpt.cars) : cpt)
                    .ToList();
            } else {
                // attempt to replace track via Traverse for unknown job types
                var replacedDestination = false;
                try {
                    var destinationTrackField = Traverse.Create(staticJobDefinition).Field("destinationTrack");
                    var carsPerDestinationTrackField = Traverse.Create(staticJobDefinition).Field("carsPerDestinationTrack");
                    if (destinationTrackField.FieldExists()) {
                        destinationTrackField.SetValue(replacementTrack);
                        replacedDestination = true;
                    } else if (carsPerDestinationTrackField.FieldExists()) {
                        carsPerDestinationTrackField.SetValue(
                            carsPerDestinationTrackField.GetValue<List<CarsPerTrack>>()
                                .Select(cpt => cpt.track == intendedDestinationTrack ? new CarsPerTrack(replacementTrack, cpt.cars) : cpt)
                                .ToList());
                        replacedDestination = true;
                    }
                } catch (Exception e) {
                    Debug.LogError(e);
                }
                if (!replacedDestination) {
                    Debug.LogError($"[PersistentJobs] Unaccounted for JobType[{staticJobDefinition.job.jobType}] encountered while reserving track space for Job[{staticJobDefinition.job.ID}].");
                }
            }

            // update task data
            foreach (var task in staticJobDefinition.job.tasks) {
                TaskUtilities.TaskDoDfs(
                    task, t => {
                        if (t is TransportTask transportTask) {
                            if (transportTask.destinationTrack == intendedDestinationTrack) {
                                transportTask.destinationTrack = replacementTrack;
                            }
                        }
                    });
            }
        }

        private static Track GetReplacementTrack(Track oldTrack, float trainLength, Random random) {
            // find station controller for track
            var allStations = UnityEngine.Object.FindObjectsOfType<StationController>();
            var stationController
                = allStations.ToList().Find(sc => sc.stationInfo.YardID == oldTrack.ID.yardId);

            // setup preferred tracks
            List<Track>[] preferredTracks;
            var stationYard = stationController.logicStation.yard;
            if (stationYard.StorageTracks.Contains(oldTrack)) {
                // shunting unload, logistical haul
                preferredTracks = new[] {
                    stationYard.StorageTracks,
                    stationYard.TransferOutTracks,
                    stationYard.TransferInTracks
                };
            } else if (stationYard.TransferInTracks.Contains(oldTrack)) {
                // freight haul
                preferredTracks = new[] {
                    stationYard.TransferInTracks,
                    stationYard.TransferOutTracks,
                    stationYard.StorageTracks
                };
            } else if (stationYard.TransferOutTracks.Contains(oldTrack)) {
                // shunting load
                preferredTracks = new[] {
                    stationYard.TransferOutTracks,
                    stationYard.StorageTracks,
                    stationYard.TransferInTracks
                };
            } else {
                Debug.LogError($"[PersistentJobs] Cant't find track group for Track[{oldTrack.ID}] in Station[{stationController.logicStation.ID}]. Skipping reservation!");
                return null;
            }

            // find track with enough free space
            Track targetTrack = null;
            var yto = YardTracksOrganizer.Instance;
            for (var p = 0; targetTrack == null && p < preferredTracks.Length; p++) {
                var trackGroup = preferredTracks[p];
                targetTrack = GetTrackThatHasEnoughFreeSpace(yto, trackGroup, trainLength, random);
            }

            if (targetTrack == null) {
                Debug.LogWarning($"[PersistentJobs] Cant't find any track to replace Track[{oldTrack.ID}] in Station[{stationController.logicStation.ID}]. Skipping reservation!");
            }

            return targetTrack;
        }

        private static Track GetTrackThatHasEnoughFreeSpace(YardTracksOrganizer yto, List<Track> tracks, float requiredLength, Random rng) {
            Main._modEntry.Logger.Log("getting random track with free space");
            var tracksWithFreeSpace = yto.FilterOutTracksWithoutRequiredFreeSpace(tracks, requiredLength);
            Main._modEntry.Logger.Log($"{tracksWithFreeSpace.Count}/{tracks.Count} tracks have at least {requiredLength}m available");
            if (tracksWithFreeSpace.Count > 0) {
                return rng.GetRandomElement(tracksWithFreeSpace);
            }

            Debug.LogWarning($"[PersistentJobsMod] None of the queried tracks have {requiredLength:F1}m of free space: {string.Join(", ", tracks.Select(t => $"{t.ID} ({yto.GetFreeSpaceOnTrack(t):F1}m)"))}");
            return null;
        }

        private static IEnumerator HandleCarsAlreadyOnWarehouseTrackCoroutine(PrinterController printerController) {
            printerController.PlayErrorSound();
            yield return WaitFor.SecondsRealtime(0.4f);
            printerController.PlayErrorSound();

            if (!Main.Settings.PreventStartingShuntingJobForCarsOnWarehouseTrackMessageWasShown) {
                Main.Settings.PreventStartingShuntingJobForCarsOnWarehouseTrackMessageWasShown = true;
                yield return WaitFor.SecondsRealtime(1);

                PopupAPI.ShowOk($"This shunting job cannot be accepted because some of the cars are already on the loading track - and that's why the job validator just beeped twice at you.{Environment.NewLine}You can disable this in the mod settings if you like.{Environment.NewLine}{Environment.NewLine}This message is only shown once.", "PersistentJobs");
            }
        }
    }
}